\documentclass[12pt,a4paper]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{patterns}

\begin{document}
    \newcommand{\LabNumber}{1}
    \include{titlepage}

    \textbf{Задача 2025. <<Стенка на стенку>>}

    Пояснение к примененному алгоритму:

    Для команды с численностью $a$ количество матчей, в которых она участвует -- $a\cdot(n-a)$.
    Тогда если у команд численность $a_1,\dots,a_k$, то итоговое число матчей --
    \[ \frac{1}{2}\sum_{i=1}^k a_i\cdot(n-a_i)
    =\frac{1}{2}\left(n\sum_{i=1}^k a_i-\sum_{i=1}^k a_i^2\right)
    =\frac{1}{2}\left(n^2-\sum_{i=1}^k a_i^2\right) \]
    Т.е. необходимо минимизировать сумму квадратов численности команд.
    Для этого распределим бойцов по командам максимально равномерно --
    $n\mod k$ команд с $n/k+1$ бойцов и $k-n\mod k$ команд с $n/k$ бойцов.
    После этого искомая сумма находится простым циклом.

    Сложность алгоритма: по времени $\Theta(T\cdot k)=\Theta(\sum_{i=1}^T k_i)$, по памяти $\Theta(1)$

    \bigskip
    \textbf{Задача 1005. <<Куча камней>>}

    Пояснение к примененному алгоритму:

    С учетом небольшого ($20$) количества камней можно решить задачу перебором всех ($2^{20}\approx 1000000$) вариантов.
    Таким образом, используем рекурсивный алгоритм перебора.

    Сложность алгоритма: по времени $\Theta(2^n)$, по памяти $\Theta(n)$

    \bigskip
    \textbf{Задача 1155. <<Дуоны>>}

    Пояснение к примененному алгоритму:

    Выделим две группы вершин: $ACFH$ и $BDEG$.

    Заметим, что любая аннигиляция или синтез происходит между двумя вершинами, находящимися в разных группах.
    Тогда разность количества дуонов между группами -- инвариант.

    При этом можно за пару операций -- синтеза и аннигиляции -- ``переместить'' дуон между двумя вершинами одной группы.

    Таким образом, аннигилировать все дуоны можно тогда и только тогда, когда количества дуонов в каждой группе вершин совпадают,
    т.е. $A+C+F+H=B+D+E+G$

    Тогда алгоритм: аннигилировать дуоны пока это возможно (порядок не важен),
    затем ``слить'' дуоны из $CFH$ в $A$,
    ``слить'' дуоны из $G$ (все остальные из 2 группы -- соседние с $A$) в $B$,
    и снова аннигилировать дуоны пока возможно.

    Сложность алгоритма: по времени $\Theta(n)$ ($n$ -- число дуонов всего), по памяти $\Theta(1)$

    \bigskip
    \textbf{Задача 1296. <<Гиперпереход>>}

    Пояснение к примененному алгоритму:

    Нужно найти наибольшую сумму подпоследовательности.

    Примем за локальное наибольшее значение в начале 0 -- сумму в подпоследовательности с нулевой длиной.

    Будем искать те суммы подпоследовательностей, которые больше локального наибольшего значения суммы подпоследовательности.

    Заметим, что если начало подпоследовательности имеет отрицательную сумму, то это начало можно ``выкинуть''.
    Тогда можно идти по всей последовательности, рассматривая сумму текущего ``хвоста'' $s$:
    \begin{itemize}
        \item $s\geq 0$ -- тогда новый элемент нужно добавлять к хвосту, хвост точно не уменьшит сумму подпоследовательности.
        \item $s<0$ -- тогда имеет смысл отбросить хвост, т.к. он уже не увеличит сумму подпоследовательности.
    \end{itemize}
    И определять новое локальное наибольшее значение.

    Локальное наибольшее значение в конце -- это и есть искомое наибольшее значение.

    Сложность алгоритма: по времени $\Theta(n)$, по памяти $\Theta(1)$

    \bigskip
    \textbf{Задача 1296. <<Гиперпереход>> (рекурсивный алгоритм)}

    Пояснение к примененному алгоритму:

    Разобьем последовательность на 2 подпоследовательности, и рекурсивно для каждой части найдем:
    \begin{itemize}
        \item Сумму всех элементов
        \item Подпоследовательность слева с наибольшей суммой
        \item Подпоследовательность справа с наибольшей суммой
        \item Подпоследовательность с наибольшей суммой
    \end{itemize}

    Для последовательности из 1 элемента они находятся тривиально.

    Для склейки двух последовательностей:
    \begin{itemize}
        \item Сумма всех элементов равна сумме таковых у обеих подпоследовательностей
        \item Подпоследовательность слева с наибольшей суммой либо совпадает с таковой у левой подпоследовательности,
        либо состоит из целиком левой подпоследовательности и подпоследовательности слева с наибольшей суммой правой подпоследовательности
        \item Аналогично для подпоследовательности справа с наибольшей суммой
        \item Подпоследовательность с наибольшей суммой либо совпадает с таковой у левой или правой подпоследовательности,
        либо состоит из подпоследовательности справа с наибольшей суммой левой подпоследовательности и подпоследовательности
        слева с наибольшей суммой правой подпоследовательности
    \end{itemize}

    Таким образом, рекурсивно находим наибольшую сумму подпоследовательности всей последовательности, что и будет
    являться ответом.

    Сложность алгоритма: по времени $\Theta(n)$, по памяти $\Theta(n)$

    Пояснение к сложности: $T(n)=T(n/2)+T(n/2)+\Theta(1)$

    \bigskip
    \textbf{Задача 1401. <<Игроки>>}

    Пояснение к примененному алгоритму:

    Докажем, что любой квадрат $2^m\times 2^m$ с вырезанной клеткой в углу можно заполнить фигурами:

    \bigskip

    \begin{center}
        \begin{tikzpicture}
            \draw[very thick] (0,0) rectangle ++(1,1);
            \draw[very thick,->] (1cm+2pt,0.5) -- ++(1cm-4pt,0);
            \draw[very thick] (2,0) rectangle ++(2,2);
            \filldraw[pattern=north west lines,thick] (2,0) rectangle ++(1,1);
            \filldraw[pattern=north east lines,thick] (2,0) ++(0,2) |- ++(1,-1) |- ++(1,-1) |- cycle;
            \draw[very thick,->] (4cm+2pt,1) -- ++(1cm-4pt,0);
            \draw[very thick] (5,0) rectangle ++(4,4);
            \filldraw[pattern=north west lines,thick] (5,0) rectangle ++(2,2);
            \filldraw[pattern=north east lines,thick] (5,0) ++(1,3) |- ++(1,-1) |- ++(1,-1) |- cycle;
            \draw[thick] (5,0) ++(0,2) -| ++(1,1) -| ++(1,1) -| cycle;
            \draw[thick] (5,0) ++(2,4) |- ++(1,-1) |- ++(1,-1) |- cycle;
            \draw[thick] (5,0) ++(2,0) |- ++(1,1) |- ++(1,1) |- cycle;
        \end{tikzpicture}
    \end{center}

    \bigskip

    Т.е. если мы сумели как-то замостить квадрат $q\times q$ с изначально вырезанным углом, то мы можем присоединить
    к нему фигуру и получить еще три квадрата $q\times q$ с вырезанными углами, которые мы также можем замостить
    и получить квадрат $2q\times 2q$, содержащий изначально замощенный $q\times q$ как один из углов.

    Тогда можно разбить изначальный квадрат $2^n\times 2^n$ на 4 квадрата $2^{n-1}\times 2^{n-1}$,
    их -- на $2^{n-2}\times 2^{n-2}$ и так далее рекурсивно до $1\times 1$.

    \bigskip

    \begin{center}
        \begin{tikzpicture}
            \foreach \i in {0,...,2}{
            \draw[very thick] (6*\i,0) rectangle ++(4,4);
            \draw[thick] (6*\i+2,0) -- ++(0,4);
            \draw[thick] (6*\i,2) -- ++(4,0);
            \foreach \j in {0,...,1}{
            \draw[dotted] (6*\i+4*\j,-0.5) -- ++(0,5);
            \draw[dotted] (6*\i-0.5,4*\j) -- ++(5,0);
            \draw (6*\i+2*\j+1,0) -- ++(0,4);
            \draw (6*\i,2*\j+1) -- ++(4,0);
            }}
            \foreach \i in {1,...,2}
            \draw[very thick,->] (6*\i-1.5,2) -- ++(1,0);
            \fill[pattern=north west lines] (3,2) rectangle ++(1,1);
            \fill[pattern=north west lines] (8,2) rectangle ++(2,2);
            \fill[pattern=north west lines] (12,0) rectangle ++(4,4);
        \end{tikzpicture}
    \end{center}

    \bigskip

    Квадрат $1\times 1$ с вырезанной клеткой -- угол квадрата $2\times 2$, в который он входит,
    этот квадрат $2\times 2$ можно замостить описанным выше способом.

    Квадрат $2\times 2$ -- угол ``своего'' квадрата $4\times 4$, и его можно замостить.

    И так далее вплоть до $2^n\times 2^n$.
    Это и есть алгоритм решения задачи.

    Сложность алгоритма: по времени $\Theta(4^n)$, по памяти $\Theta(4^n)$
\end{document}

\documentclass[12pt,a4paper]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{amsmath}

\begin{document}
    \newcommand{\LabNumber}{4}
    \include{titlepage}

    \textbf{Задача 1080. Раскраска карты.}

    Пояснение к примененному алгоритму:

    Пусть в графе вершины -- это страны, а ребра -- границы между ними.
    Будем хранить ребра в виде матрицы смежности.

    Воспользуемся алгоритмом коллапса волновой функции:
    \begin{itemize}
        \item Изначально имеем нераскрашенный граф
        \item Проходим по всем вершинам
        \item Если встретили незакрашенную вершину
        \begin{itemize}
            \item Красим ее и всех соседей пока существует однозначность (таким образом, раскрашена будет вся компонента связности)
            \item Если не можем покрасить вершину (при покраске она соседствует с вершинами разных цветов) -- раскраски нет, выходим
        \end{itemize}
    \end{itemize}

    Таким образом получаем либо раскрашенный граф, либо невозможность раскраски, из этого можно вывести ответ.

    Сложность алгоритма: по времени $O(N)$, по памяти $O(N^2)$

    \bigskip

    \textbf{Задача 1450. Российские газопроводы.}

    Пояснение к примененному алгоритму:

    Пусть в графе вершины -- это станции, а ребра -- трубы.
    Будем хранить ребра в виде массива.

    Воспользуемся алгоритмом Форда-Беллмана:

    Зададим для каждой вершины вес: для начальной -- $0$, для всех остальных -- $(-\infty)$.
    Далее в бесконечном цикле:
    \begin{itemize}
        \item Проходим по всем ребрам:
        \begin{itemize}
            \item Увеличиваем вес вершины проходом по ребру, если возможно
        \end{itemize}
        \item Если вес ни одной вершины не изменился -- выходим
    \end{itemize}

    Таким образом, если путь существует, то в конечной вершине окажется цена максимального пути,
    в противном случае там окажется $(-\infty)$, из этого можно вывести ответ.

    Сложность алгоритма: по времени $O(MN^2)$, по памяти $O(M+N)$

    \bigskip

    \textbf{Задача 1160. Network.}

    Пояснение к примененному алгоритму:

    Пусть в графе вершины -- это хабы, а ребра -- провода.
    Будем хранить ребра в виде массива.

    Отсортируем возможные ребра в порядке возрастания веса.
    Пометим каждую вершину как принадлежащую собственной компоненте связности.

    Пройдем по всем ребрам в порядке возрастания:
    \begin{itemize}
        \item Объединяем компоненты связности ребром, если это возможно.
        При этом нужно пройти по всем вершинам этих компонент связности и пометить их как
        принадлежащие одной компоненте связности.
    \end{itemize}

    Таким образом в итоге получаем связный граф, максимальный вес ребра в котором минимален,
    из этого можно вывести ответ.

    Сложность алгоритма: по времени $O(MN)$, по памяти $O(M+N)$

    \bigskip

    \textbf{Задача 1162. Currency Exchange.}

    Пояснение к примененному алгоритму:

    Пусть в графе вершины -- это валюты, а направленные ребра -- обменники.
    Будем хранить ребра в виде массива.

    Воспользуемся алгоритмом Форда-Беллмана:
    Зададим для каждой вершины вес: для вершины $S$ -- $V$, для всех остальных -- $0$.
    Далее в бесконечном цикле:
    \begin{itemize}
        \item Если в вершине $S$ вес больше $V$, то спекуляция существует, из этого можно вывести ответ.
        \item Проходим по всем ребрам:
        \begin{itemize}
            \item Увеличиваем вес проходом по ребру, если возможно
        \end{itemize}
        \item Если вес ни одной вершины не изменился, то спекуляция невозможна, из этого можно вывести ответ.
    \end{itemize}

    Сложность алгоритма: по времени $O(MN^2)$, по памяти $O(M+N)$

    \bigskip

    \textbf{Зачача 1806. Мобильные телеграфы.}

    Пояснение к примененному алгоритму:

    Пусть вершины графа -- телеграфы, а ребра -- передачи.
    Будем хранить ребра в виде вектора в каждой вершине.

    Построение графа: запишем в хеш-таблицу идентификаторы телеграфов от их номеров.
    Пройдем по всем номерам и попытаемся установить ребра перебором набираемых номеров.
    Добавляем ребро только если оно соединяет две разные вершины.
    Затем пройдем по всем вершинам и удалим дублирующиеся ребра.
    После построения графа хеш-таблица уже не нужна.

    Для поиска пути по графу воспользуемся алгоритмом Дейкстры:

    Зададим для всех вершин вес: для начальной -- $0$, для всех остальных -- $(+\infty)$.
    Создадим пирамиду и положим в нее начальную вершину
    (На вершине пирамиды наименьший вес вершины).
    Далее пока пирамида не пуста:
    \begin{itemize}
        \item Извлечем вершину пирамиды $A$
        \begin{itemize}
            \item Поменяем местами вершину $A$ и последний лист $Q$
            \item Извлечем $A$
            \item Просеим вниз вершину $Q$
        \end{itemize}
        \item Пройдем по всем ребрам $AB$ вершины $A$.
        Если возможно уменьшить вес вершины $B$ проходом по ребру $AB$ ($w(A)+w(AB)<w(B)$):
        \begin{itemize}
            \item Уменьшаем вес $w(B)=w(A)+w(AB)$
            \item Записываем, что в вершину $B$ пришли из $A$
            \item Добавляем вершину $B$ в пирамиду и просеиваем вверх
        \end{itemize}
    \end{itemize}

    Если вес последней вершины конечен, то он минимален и можно восстановить путь с минимальным весом.
    В противном случае пути не существует.
    Из этого можно вывести ответ.

    Сложность алгоритма: по времени $O(N\log N)$, по памяти $O(N)$

\end{document}

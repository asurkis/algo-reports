\documentclass[12pt,a4paper]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{amsmath}

\begin{document}
    \newcommand{\LabNumber}{3}
    \include{titlepage}

    \textbf{Задача 1067. Disk Tree}

    Пояснение к примененному алгоритму:

    Представим дерево файловой системы как дерево, в котором у родителя есть словарь ребер до детей.
    Тогда можно разбить абсолютные пути на списки имен поддиректорий, и, проходя по ним, восстанавливать
    структуру дерева.
    После этого вывод производится с помощью рекурсивного прохода по дереву.

    Сложность алгоритма: по времени $O(SN)$, по памяти $O(SN)$.

    \bigskip

    \textbf{Задача 1494. Монобильярд}

    Пояснение к примененному алгоритму:

    Заведем стек бильярдных шаров и счетчик номера последнего шара, который закатил Чичиков.
    На каждый шар, вытащенный ревизором сравниваем его с вершиной стека (если стек пуст, добавляем один шар):
    если вершина стека больше номера шара, вытащенного ревизором, то Чичиков мошенник.
    Если же нет, то добавляем шары в стек, пока вершина не сравняется с номером вытащенного шара,
    и затем удаляем вершину.

    Сложность алгоритма: по времени $O(N)$, по памяти $O(N)$.

    \bigskip

    \textbf{Задача 1521. Военные учения 2}

    Пояснение к примененному алгоритму:

    Построим дерево поиска $i$-го от начала из оставшихся солдат.
    Пусть $2^{q-1}<N\leq 2^q=Q$.
    Построим полное двоичное дерево с $Q$ листьев, в $N$ первых из которых будет записано $1$, а в оставшихся $0$.
    В родителях запишем сумму значений в потомках.
    Тогда поиск $i$-го из ненулевых листьев -- двоичный.
    После этого циклом проходим циклом из $N$ итераций, причем $p_{i+1}=(p_i+K-1)\%r$,
    где $p$ -- искомый ненулевой лист, а $r$ -- значение в корне дерева.

    Сложность алгоритма: по времени $O(N\log N)$, по памяти $O(N)$.

    \bigskip

    \textbf{Задача 1628. Белые полосы}

    Пояснение к примененному алгоритму:

    Составим список неудачных дней.
    Отсортируем его в порядке $(i;j)$.
    Пройдем по всем столбцам календаря, и считаем количество отрезков длины больше 1.
    Отдельные клетки (отрезки длины 1) заносим в список исключенных из первого прохода.
    Отсортируем списки неудачных дней и дней, исключенных из первого прохода, в порядке $(j;i)$.
    Пройдем по всем строкам календаря, считаем количество отрезков длины больше 1 и
    количество отдельных клеток, исключенных из первого прохода.

    Суммируя три счетчика, получим результат.

    Сложность алгоритма: по времени $O((m+n)k)$, по памяти $O(k)$.

    \bigskip

    \textbf{Задача 1650. Миллиардеры}

    Пояснение к примененному алгоритму:

    Составим словари имя-город и имя-миллиардер.
    Построим пирамиду, узлы которой -- города с информацией о текущем состоянии и положении в куче
    (т.е. индекс, меняющийся при перестановке городов в пирамиде).
    При каждом перемещении миллиардера просеиваем вниз город, из которого он улетел, и вверх город,
    в который он прилетел.
    Сортируем города по количеству дней, в течение которых они были в корне, и выводим ответ.

    Сложность алгоритма: по времени $O(k\log q)$, по памяти $O(n+q)$, где $q$ -- количество городов.

\end{document}
